//------------------------------------------------
//--- 010 Editor v11.0.1 Binary Template
//
//      File: re5_mod.bt
//   Authors: Raq, also special thanks to TheIndra & alphaZomega
//   Version: 2.0
//   Purpose: Parsing Resident evil 5 mesh format
//  Category: Modding
// File Mask: .mod
//  ID Bytes: 4D 4F 44 0
//------------------------------------------------
LittleEndian();
local uint64 i<hidden=true>;
local uint64 j<hidden=true>;
local uint64 mesh_offset<hidden=true>;

struct mod_header {
    char id_magic[4];
    ubyte version;
    byte revision;
    ushort num_bones;
    short num_meshes;
    ushort num_materials;
    uint num_vertices;
    uint num_faces;
    uint num_edges;
    uint size_vertex_buffer;
    uint size_vertex_buffer_2;
    uint num_textures;
    uint num_groups;
    uint num_bone_mappings;
    uint offset_bones;
    uint offset_groups;
    uint offset_textures;
    uint offset_meshes;
    uint offset_buffer_vertices;
    uint offset_buffer_vertices_2; // 8 bones per vertex related
    uint offset_buffer_indices;
    uint reserved_01;
    uint reserved_02;
    float sphere_x;
    float sphere_y;
    float sphere_z;
    float sphere_w;
    float box_min_x;
    float box_min_y;
    float box_min_z;
    float box_min_w;
    float box_max_x;
    float box_max_y;
    float box_max_z;
    float box_max_w;
    uint unk_01;
    uint unk_02;
    uint unk_03;
    uint unk_04;
    uint unk_05;
    uint unk_06;
    uint unk_07;
    uint unk_08;
    uint unk_09;
    uint unk_10;
    uint unk_11;
    uint reserved_03;
};

struct bone{
	ubyte anim_map_index;
	ubyte parent_index; //255: root
	ubyte mirror_index;
	ubyte palette_index;
	float unk_01;
	float parent_distance;
	float location_x;
	float location_y;
	float location_z;
};
struct matrix_4x4{
    float matrix[16];
};

struct bone_anim_mapping {
	ubyte a[256];
} ;

 struct bone_mapping {
        uint unk_01;
        ubyte values[32];
 } ;
 
struct  group{
        uint group_index;
        float unk_02;
        float unk_03;
        float unk_04;
        float unk_05;
        float unk_06;
        float unk_07;
        float unk_08;
};

struct texture_data {
        char path[64];
};

struct material_data{
    ushort unk_01;
    struct {
        uint16 unk_flag_01 : 1;
        uint16 unk_flag_02 : 1;
        uint16 unk_flag_03 : 1;
        uint16 unk_flag_04 : 1;
        uint16 unk_flag_05 : 1;
        uint16 unk_flag_06 : 1;
        uint16 unk_flag_07 : 1;
        uint16 unk_flag_08 : 1;
        uint16 unk_flag_09 : 1;
        uint16 unk_flag_10 : 1;
        uint16 unk_flag_11 : 1;
        uint16 flag_8_bones_per_vertex : 1;
        uint16 unk_flag_13 : 1;
        uint16 unk_flag_14 : 1;
        uint16 unk_flag_15 : 1;
        uint16 unk_flag_16 : 1;
    } unk_flag;
    ushort unk_02[10];
    uint texture_indices[8];
    float unk_12[26];
};

struct mod_mesh{
    ushort group_index;
    ushort material_index;
    ubyte constant; //always 1
    ubyte level_of_detail;
    ubyte unk_01;
    ubyte vertex_format;
    ubyte vertex_stride;
    ubyte vertex_stride_2;
    ubyte unk_03;
    ubyte unk_flags;
    ushort num_vertices;
    ushort vertex_index_end;
    uint vertex_index_start_1;
    uint vertex_offset;
    uint unk_05;
    uint face_position;
    uint num_faces;
    uint face_offset;
    ubyte unk_06;
    ubyte unk_07;
    ushort vertex_index_start_2;
    ubyte vertex_num_groups;
    ubyte bone_palette_index;
    ubyte unk_08;
    ubyte unk_09;
    ushort unk_10;
    ushort unk_11;
};

struct vtx0 {
    short position_x;
    short position_y;
    short position_z;
    ubyte normal_x;
    ubyte normal_y;
    ubyte normal_z;
    ubyte normal_w;
    ubyte tangent_x;
    ubyte tangent_y;
    ubyte tangent_z;
    ubyte tangent_w;
    ushort uv_x;
    ushort uv_y;
    ushort uv2_x;
    ushort uv2_y;
    ushort uv3_x;
    ushort uv3_y;
};

struct vtx{
        short position_x;
        short position_y;
        short position_z;
        short position_w;
        struct {
            ubyte index_1;
            ubyte index_2;
            ubyte index_3;
            ubyte index_4;
        } bone_indices;
        struct {
            ubyte index_1;
            ubyte index_2;
            ubyte index_3;
            ubyte index_4;
        } weight_values;
        ubyte normal_x;
        ubyte normal_y;
        ubyte normal_z;
        ubyte normal_w;
        ubyte tangent_x;
        ubyte tangent_y;
        ubyte tangent_z;
        ubyte tangent_w;
        ushort uv_x;
        ushort uv_y;
        ushort uv2_x;
        ushort uv2_y;
};

struct vtx5{
    short position_x;
    short position_y;
    short position_z;
    short position_w;
    struct {
        ubyte index_1;
        ubyte index_2;
        ubyte index_3;
        ubyte index_4;
        ubyte index_5;
        ubyte index_6;
        ubyte index_7;
        ubyte index_8;
    } bone_indices;
    struct {
        ubyte index_1;
        ubyte index_2;
        ubyte index_3;
        ubyte index_4;
        ubyte index_5;
        ubyte index_6;
        ubyte index_7;
        ubyte index_8;
    } weight_values;
    ubyte normal_x;
    ubyte normal_y;
    ubyte normal_z;
    ubyte normal_w;
    ushort uv_x;
    ushort uv_y;
};

struct mesh_data{
    uint boneID;
    float unk_01[3];
    float bssphere[4];
    float bboxMin[4];
    float bboxMax[4];
    float oabb_matrix[16];
    float oabb_dimension[4];
};

struct tangent{ // only guess
    ubyte tangent_x;
    ubyte tangent_y;
    ubyte tangent_z;
    ubyte tangent_w;
};

//Parsing//
mod_header Header<fgcolor=0x008000>;

if (Header.num_bones > 0) {
    FSeek(Header.offset_bones);
    bone Bones[Header.num_bones]<fgcolor=0x008080>; 
    matrix_4x4 Matrix_local_transform[Header.num_bones];
    matrix_4x4 World_local_transform[Header.num_bones];
    bone_anim_mapping Bone_map;
    bone_mapping Bones_mapping[Header.num_bone_mappings];
};
FSeek(Header.offset_groups);
group Groups[Header.num_groups];
FSeek(Header.offset_textures);
texture_data Textures[Header.num_textures];
material_data Materials[Header.num_materials];

struct{
    FSeek(Header.offset_meshes);
    mesh_offset = FTell();
    for(i=0; i<(Header.num_meshes); i++) {
        FSeek(mesh_offset);
        mod_mesh Mesh;
        mesh_offset = FTell();
        struct {
            for(j=0; j<(Mesh.num_vertices); j++){
                if (Mesh.vertex_format == 0) {
                    vtx0 Vertex0<fgcolor=cRed>;
                }
                else if (Mesh.vertex_format <= 4) {
                    vtx Vertex<fgcolor=cPurple>;
                }
                else{
                    vtx5 Vertex5<fgcolor=0xD1CE00>;
                };
            };
        }Vertices;
    };   
}Meshes;

FSeek(mesh_offset);
uint NumMeshData<fgcolor=cRed>;
mesh_data MeshData[NumMeshData]<fgcolor=cGreen>;

if (Header.offset_buffer_vertices_2 != 0) {
    if (Header.offset_buffer_vertices_2 != Header.offset_buffer_indices) {
        tangent Tangent [(Header.size_vertex_buffer_2)/4]<fgcolor=0xADA2EE>;
    };
};

FSeek(Header.offset_buffer_indices);
struct {
    ushort index1;
} Indexes[Header.num_faces -1]<fgcolor=cYellow>; //- 2 for modified files